# app/exchanges/okx/live_client.py
import os
import time
import hmac
import hashlib
import base64
import json
import requests
from typing import Dict, List, Optional, Tuple
from datetime import datetime
from decimal import Decimal, ROUND_DOWN
import logging

logger = logging.getLogger(__name__)

class OKXLiveClient:
    """OKX ì‹¤ê±°ë˜ í´ë¼ì´ì–¸íŠ¸"""
    
    def __init__(self):
        # í™˜ê²½ë³€ìˆ˜ì—ì„œ API í‚¤ ë¡œë“œ
        self.api_key = os.getenv('OKX_API_KEY')
        self.secret_key = os.getenv('OKX_SECRET_KEY') 
        self.passphrase = os.getenv('OKX_PASSPHRASE')
        self.base_url = os.getenv('OKX_BASE_URL', 'https://www.okx.com')
        
        # ì‹¤ê±°ë˜ ì•ˆì „ ì„¤ì •
        self.max_position_size = float(os.getenv('MAX_POSITION_SIZE', '100.0'))
        self.min_order_size = float(os.getenv('MIN_ORDER_SIZE', '5.0'))
        self.risk_limit_percent = float(os.getenv('RISK_LIMIT_PERCENT', '10.0'))
        
        # ì‹¤ê±°ë˜ í™•ì¸
        self.live_trading_enabled = os.getenv('LIVE_TRADING_ENABLED', 'false').lower() == 'true'
        self.demo_mode = os.getenv('DEMO_MODE', 'true').lower() == 'true'
        
        # API í‚¤ ê²€ì¦
        if not all([self.api_key, self.secret_key, self.passphrase]):
            raise ValueError("OKX API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. .env íŒŒì¼ì„ í™•ì¸í•˜ì„¸ìš”.")
        
        if not self.live_trading_enabled:
            raise ValueError("ì‹¤ê±°ë˜ê°€ í™œì„±í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. LIVE_TRADING_ENABLED=trueë¡œ ì„¤ì •í•˜ì„¸ìš”.")
            
        logger.info(f"OKX ì‹¤ê±°ë˜ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ")
        logger.info(f"ìµœëŒ€ í¬ì§€ì…˜: ${self.max_position_size}, ìµœì†Œ ì£¼ë¬¸: ${self.min_order_size}")
    
    def _generate_signature(self, timestamp: str, method: str, request_path: str, body: str = '') -> str:
        """API ìš”ì²­ ì„œëª… ìƒì„±"""
        message = timestamp + method + request_path + body
        mac = hmac.new(
            bytes(self.secret_key, encoding='utf8'),
            bytes(message, encoding='utf-8'),
            digestmod=hashlib.sha256
        )
        return base64.b64encode(mac.digest()).decode()
    
    def _get_headers(self, method: str, request_path: str, body: str = '') -> Dict[str, str]:
        """API ìš”ì²­ í—¤ë” ìƒì„±"""
        timestamp = self._get_timestamp()
        signature = self._generate_signature(timestamp, method, request_path, body)
        
        return {
            'OK-ACCESS-KEY': self.api_key,
            'OK-ACCESS-SIGN': signature,
            'OK-ACCESS-TIMESTAMP': timestamp,
            'OK-ACCESS-PASSPHRASE': self.passphrase,
            'Content-Type': 'application/json'
        }
    
    def _get_timestamp(self) -> str:
        """í˜„ì¬ íƒ€ì„ìŠ¤íƒ¬í”„ ë°˜í™˜"""
        return str(time.time())
    
    def _make_request(self, method: str, endpoint: str, params: Dict = None, data: Dict = None) -> Dict:
        """API ìš”ì²­ ì‹¤í–‰"""
        url = f"{self.base_url}{endpoint}"
        body = json.dumps(data) if data else ''
        headers = self._get_headers(method, endpoint, body)
        
        try:
            if method == 'GET':
                response = requests.get(url, headers=headers, params=params, timeout=10)
            elif method == 'POST':
                response = requests.post(url, headers=headers, data=body, timeout=10)
            else:
                raise ValueError(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” HTTP ë©”ì„œë“œ: {method}")
            
            response.raise_for_status()
            result = response.json()
            
            # OKX API ì‘ë‹µ ì½”ë“œ í™•ì¸
            if result.get('code') != '0':
                raise Exception(f"OKX API ì˜¤ë¥˜: {result.get('msg', 'Unknown error')}")
            
            return result
        
        except requests.exceptions.RequestException as e:
            logger.error(f"API ìš”ì²­ ì‹¤íŒ¨: {e}")
            raise
        except Exception as e:
            logger.error(f"API ì‘ë‹µ ì²˜ë¦¬ ì‹¤íŒ¨: {e}")
            raise
    
    def get_account_balance(self) -> Dict:
        """ê³„ì¢Œ ì”ê³  ì¡°íšŒ"""
        logger.info("ê³„ì¢Œ ì”ê³  ì¡°íšŒ ì¤‘...")
        
        response = self._make_request('GET', '/api/v5/account/balance')
        
        balances = {}
        for detail in response['data'][0]['details']:
            currency = detail['ccy']
            available = float(detail['availBal'])
            if available > 0:
                balances[currency] = {
                    'available': available,
                    'total': float(detail['bal']),
                    'frozen': float(detail['frozenBal'])
                }
        
        logger.info(f"ì”ê³  ì¡°íšŒ ì™„ë£Œ: {len(balances)}ê°œ í†µí™”")
        return balances
    
    # get_balance ë³„ì¹­ ì¶”ê°€ (í˜¸í™˜ì„±)
    def get_balance(self) -> Dict:
        """get_account_balanceì™€ ë™ì¼ (í˜¸í™˜ì„±ìš©)"""
        return self.get_account_balance()

    def get_ticker(self, symbol: str) -> Dict:
        """ì‹¤ì‹œê°„ ì‹œì„¸ ì¡°íšŒ"""
        response = self._make_request('GET', '/api/v5/market/ticker', {'instId': symbol})
        
        if not response['data']:
            raise ValueError(f"ì‹¬ë³¼ {symbol}ì˜ ì‹œì„¸ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        
        ticker_data = response['data'][0]
        return {
            'symbol': ticker_data['instId'],
            'last_price': float(ticker_data['last']),
            'bid_price': float(ticker_data['bidPx']),
            'ask_price': float(ticker_data['askPx']),
            'high_24h': float(ticker_data['high24h']),
            'low_24h': float(ticker_data['low24h']),
            'volume_24h': float(ticker_data['vol24h']),
            'timestamp': int(ticker_data['ts'])
        }
    
    def validate_order_safety(self, symbol: str, side: str, size: float, price: float = None) -> bool:
        """ì£¼ë¬¸ ì•ˆì „ì„± ê²€ì¦"""
        # ìµœì†Œ ì£¼ë¬¸ í¬ê¸° í™•ì¸
        if size < self.min_order_size:
            logger.warning(f"ì£¼ë¬¸ í¬ê¸°ê°€ ìµœì†Œê°’ë³´ë‹¤ ì‘ìŒ: {size} < {self.min_order_size}")
            return False
        
        # ìµœëŒ€ í¬ì§€ì…˜ í¬ê¸° í™•ì¸
        if size > self.max_position_size:
            logger.warning(f"ì£¼ë¬¸ í¬ê¸°ê°€ ìµœëŒ€ê°’ë³´ë‹¤ í¼: {size} > {self.max_position_size}")
            return False
        
        # ê³„ì¢Œ ì”ê³  í™•ì¸
        balances = self.get_account_balance()
        
        if side == 'buy':
            # ë§¤ìˆ˜ì˜ ê²½ìš° USDT ì”ê³  í™•ì¸
            usdt_balance = balances.get('USDT', {}).get('available', 0)
            required_amount = size if price is None else size * price
            
            if usdt_balance < required_amount:
                logger.warning(f"USDT ì”ê³  ë¶€ì¡±: {usdt_balance} < {required_amount}")
                return False
        
        return True
    
    def place_market_order(self, symbol: str, side: str, size: float) -> Dict:
        """ì‹œì¥ê°€ ì£¼ë¬¸"""
        logger.info(f"ì‹œì¥ê°€ ì£¼ë¬¸ ì‹¤í–‰: {symbol} {side} {size}")
        
        # ì•ˆì „ì„± ê²€ì¦
        if not self.validate_order_safety(symbol, side, size):
            raise ValueError("ì£¼ë¬¸ ì•ˆì „ì„± ê²€ì¦ ì‹¤íŒ¨")
        
        # ì‹¤ê±°ë˜ ì¬í™•ì¸
        if self.demo_mode:
            logger.warning("ë°ëª¨ ëª¨ë“œì—ì„œëŠ” ì‹¤ì œ ì£¼ë¬¸ì´ ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            return {'demo': True, 'order_id': 'demo_' + str(int(time.time()))}
        
        order_data = {
            'instId': symbol,
            'tdMode': 'cash',  # í˜„ë¬¼ ê±°ë˜
            'side': side,
            'ordType': 'market',
            'sz': str(size)
        }
        
        logger.warning(f"ğŸš¨ ì‹¤ê±°ë˜ ì£¼ë¬¸ ì‹¤í–‰: {order_data}")
        response = self._make_request('POST', '/api/v5/trade/order', data=order_data)
        
        if response['data']:
            order_info = response['data'][0]
            logger.info(f"âœ… ì£¼ë¬¸ ì„±ê³µ: {order_info['ordId']}")
            return {
                'order_id': order_info['ordId'],
                'client_order_id': order_info.get('clOrdId'),
                'symbol': symbol,
                'side': side,
                'size': size,
                'status': 'submitted',
                'timestamp': int(time.time() * 1000)
            }
        else:
            raise Exception("ì£¼ë¬¸ ì‹¤í–‰ ì‹¤íŒ¨: ì‘ë‹µ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
    
    def place_limit_order(self, symbol: str, side: str, size: float, price: float) -> Dict:
        """ì§€ì •ê°€ ì£¼ë¬¸"""
        logger.info(f"ì§€ì •ê°€ ì£¼ë¬¸ ì‹¤í–‰: {symbol} {side} {size} @ {price}")
        
        # ì•ˆì „ì„± ê²€ì¦
        if not self.validate_order_safety(symbol, side, size, price):
            raise ValueError("ì£¼ë¬¸ ì•ˆì „ì„± ê²€ì¦ ì‹¤íŒ¨")
        
        # ì‹¤ê±°ë˜ ì¬í™•ì¸
        if self.demo_mode:
            logger.warning("ë°ëª¨ ëª¨ë“œì—ì„œëŠ” ì‹¤ì œ ì£¼ë¬¸ì´ ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            return {'demo': True, 'order_id': 'demo_' + str(int(time.time()))}
        
        order_data = {
            'instId': symbol,
            'tdMode': 'cash',  # í˜„ë¬¼ ê±°ë˜
            'side': side,
            'ordType': 'limit',
            'sz': str(size),
            'px': str(price)
        }
        
        logger.warning(f"ğŸš¨ ì‹¤ê±°ë˜ ì£¼ë¬¸ ì‹¤í–‰: {order_data}")
        response = self._make_request('POST', '/api/v5/trade/order', data=order_data)
        
        if response['data']:
            order_info = response['data'][0]
            logger.info(f"âœ… ì£¼ë¬¸ ì„±ê³µ: {order_info['ordId']}")
            return {
                'order_id': order_info['ordId'],
                'client_order_id': order_info.get('clOrdId'),
                'symbol': symbol,
                'side': side,
                'size': size,
                'price': price,
                'status': 'submitted',
                'timestamp': int(time.time() * 1000)
            }
        else:
            raise Exception("ì£¼ë¬¸ ì‹¤í–‰ ì‹¤íŒ¨: ì‘ë‹µ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
    
    def get_order_status(self, symbol: str, order_id: str) -> Dict:
        """ì£¼ë¬¸ ìƒíƒœ ì¡°íšŒ"""
        params = {
            'instId': symbol,
            'ordId': order_id
        }
        
        response = self._make_request('GET', '/api/v5/trade/order', params=params)
        
        if response['data']:
            order_data = response['data'][0]
            return {
                'order_id': order_data['ordId'],
                'symbol': order_data['instId'],
                'side': order_data['side'],
                'size': float(order_data['sz']),
                'filled_size': float(order_data['fillSz']),
                'price': float(order_data.get('px', 0)),
                'avg_price': float(order_data.get('avgPx', 0)),
                'status': order_data['state'],
                'timestamp': int(order_data['uTime'])
            }
        else:
            raise ValueError(f"ì£¼ë¬¸ {order_id}ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    
    def cancel_order(self, symbol: str, order_id: str) -> bool:
        """ì£¼ë¬¸ ì·¨ì†Œ"""
        logger.info(f"ì£¼ë¬¸ ì·¨ì†Œ: {order_id}")
        
        cancel_data = {
            'instId': symbol,
            'ordId': order_id
        }
        
        response = self._make_request('POST', '/api/v5/trade/cancel-order', data=cancel_data)
        
        if response['data'] and response['data'][0]['sCode'] == '0':
            logger.info(f"âœ… ì£¼ë¬¸ ì·¨ì†Œ ì„±ê³µ: {order_id}")
            return True
        else:
            logger.error(f"âŒ ì£¼ë¬¸ ì·¨ì†Œ ì‹¤íŒ¨: {order_id}")
            return False
    
    def get_positions(self) -> List[Dict]:
        """í¬ì§€ì…˜ ì¡°íšŒ (ì„ ë¬¼ìš©)"""
        response = self._make_request('GET', '/api/v5/account/positions')
        
        positions = []
        for pos_data in response['data']:
            if float(pos_data['pos']) != 0:  # í¬ì§€ì…˜ì´ ìˆëŠ” ê²½ìš°ë§Œ
                positions.append({
                    'symbol': pos_data['instId'],
                    'side': pos_data['posSide'],
                    'size': float(pos_data['pos']),
                    'avg_price': float(pos_data['avgPx']),
                    'mark_price': float(pos_data['markPx']),
                    'unrealized_pnl': float(pos_data['upl']),
                    'unrealized_pnl_ratio': float(pos_data['uplRatio']),
                    'timestamp': int(pos_data['uTime'])
                })
        
        return positions