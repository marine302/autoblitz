# app/exchanges/okx/client.py

import asyncio
import ccxt.async_support as ccxt
import logging
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime, timezone
import json
from app.core.config import settings

logger = logging.getLogger(__name__)


class OKXClient:
    """OKX 거래소 API 클라이언트"""

    def __init__(self, api_key: str = None, secret_key: str = None, passphrase: str = None, sandbox: bool = None):
        self.api_key = api_key or settings.OKX_API_KEY
        self.secret_key = secret_key or settings.OKX_SECRET_KEY
        self.passphrase = passphrase or settings.OKX_PASSPHRASE
        self.sandbox = sandbox if sandbox is not None else settings.OKX_SANDBOX

        if not all([self.api_key, self.secret_key, self.passphrase]):
            raise ValueError("OKX API 키가 올바르게 설정되지 않았습니다. .env 파일을 확인해주세요.")

        # CCXT OKX 거래소 인스턴스 생성
        self.exchange = ccxt.okx({
            'apiKey': self.api_key,
            'secret': self.secret_key,
            'password': self.passphrase,
            'sandbox': self.sandbox,  # True: 테스트넷, False: 실서버
            'enableRateLimit': True,
            'options': {
                'defaultType': 'spot',  # 'spot', 'future', 'swap'
            }
        })

        self.is_connected = False

    async def initialize(self):
        """클라이언트 초기화 및 연결 테스트"""
        try:
            # 거래소 로드
            await self.exchange.load_markets()

            # 계정 정보 조회로 연결 테스트
            balance = await self.exchange.fetch_balance()

            self.is_connected = True
            logger.info("OKX API 연결 성공")
            logger.info(
                f"사용 가능한 USDT: {balance.get('USDT', {}).get('free', 0)}")

            return True

        except Exception as e:
            logger.error(f"OKX API 연결 실패: {e}")
            self.is_connected = False
            return False

    async def close(self):
        """연결 종료"""
        if self.exchange:
            await self.exchange.close()
            self.is_connected = False
            logger.info("OKX API 연결 종료")

    # ===== 시장 데이터 조회 =====

    async def get_ticker(self, symbol: str) -> Optional[Dict]:
        """티커 정보 조회"""
        try:
            ticker = await self.exchange.fetch_ticker(symbol)
            return {
                'symbol': symbol,
                'last': float(ticker['last']),
                'bid': float(ticker['bid']),
                'ask': float(ticker['ask']),
                'high': float(ticker['high']),
                'low': float(ticker['low']),
                'volume': float(ticker['baseVolume']),
                'timestamp': ticker['timestamp']
            }
        except Exception as e:
            logger.error(f"티커 조회 실패 ({symbol}): {e}")
            return None

    async def get_orderbook(self, symbol: str, limit: int = 20) -> Optional[Dict]:
        """호가창 정보 조회"""
        try:
            orderbook = await self.exchange.fetch_order_book(symbol, limit)
            return {
                'symbol': symbol,
                'bids': [[float(price), float(amount)] for price, amount in orderbook['bids'][:limit]],
                'asks': [[float(price), float(amount)] for price, amount in orderbook['asks'][:limit]],
                'timestamp': orderbook['timestamp']
            }
        except Exception as e:
            logger.error(f"호가창 조회 실패 ({symbol}): {e}")
            return None

    async def get_klines(self, symbol: str, timeframe: str = '1m', limit: int = 100) -> Optional[List]:
        """K라인(캔들) 데이터 조회"""
        try:
            ohlcv = await self.exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
            return [
                {
                    'timestamp': candle[0],
                    'open': float(candle[1]),
                    'high': float(candle[2]),
                    'low': float(candle[3]),
                    'close': float(candle[4]),
                    'volume': float(candle[5])
                }
                for candle in ohlcv
            ]
        except Exception as e:
            logger.error(f"K라인 조회 실패 ({symbol}): {e}")
            return None

    # ===== 계정 정보 조회 =====

    async def get_balance(self) -> Optional[Dict]:
        """계정 잔고 조회"""
        try:
            balance = await self.exchange.fetch_balance()

            # 주요 코인들만 필터링 (잔고가 있는 것들)
            filtered_balance = {}
            for currency, info in balance.items():
                if isinstance(info, dict) and info.get('total', 0) > 0:
                    filtered_balance[currency] = {
                        'free': float(info.get('free', 0)),
                        'used': float(info.get('used', 0)),
                        'total': float(info.get('total', 0))
                    }

            return filtered_balance

        except Exception as e:
            logger.error(f"잔고 조회 실패: {e}")
            return None

    async def get_positions(self, symbol: str = None) -> Optional[List[Dict]]:
        """포지션 조회 (선물/스왑용)"""
        try:
            positions = await self.exchange.fetch_positions(symbols=[symbol] if symbol else None)

            # 활성 포지션만 필터링
            active_positions = []
            for position in positions:
                if position['size'] > 0:  # 포지션 크기가 0보다 큰 것만
                    active_positions.append({
                        'symbol': position['symbol'],
                        'side': position['side'],  # 'long' or 'short'
                        'size': float(position['size']),
                        'notional': float(position['notional']),
                        'unrealized_pnl': float(position['unrealizedPnl']),
                        'percentage': float(position['percentage']),
                        'entry_price': float(position['entryPrice']),
                        'mark_price': float(position['markPrice'])
                    })

            return active_positions

        except Exception as e:
            logger.error(f"포지션 조회 실패: {e}")
            return None

    # ===== 주문 관리 =====

    async def create_market_order(self, symbol: str, side: str, amount: float, params: Dict = None) -> Optional[Dict]:
        """시장가 주문"""
        try:
            if params is None:
                params = {}

            order = await self.exchange.create_market_order(symbol, side, amount, None, params)

            return {
                'id': order['id'],
                'symbol': symbol,
                'side': side,
                'amount': float(order['amount']),
                'price': float(order.get('price', 0)) if order.get('price') else None,
                'cost': float(order.get('cost', 0)),
                'status': order['status'],
                'timestamp': order['timestamp'],
                'type': 'market'
            }

        except Exception as e:
            logger.error(f"시장가 주문 실패 ({symbol} {side} {amount}): {e}")
            return None

    async def create_limit_order(self, symbol: str, side: str, amount: float, price: float, params: Dict = None) -> Optional[Dict]:
        """지정가 주문"""
        try:
            if params is None:
                params = {}

            order = await self.exchange.create_limit_order(symbol, side, amount, price, params)

            return {
                'id': order['id'],
                'symbol': symbol,
                'side': side,
                'amount': float(order['amount']),
                'price': float(order['price']),
                'cost': float(order.get('cost', 0)),
                'status': order['status'],
                'timestamp': order['timestamp'],
                'type': 'limit'
            }

        except Exception as e:
            logger.error(f"지정가 주문 실패 ({symbol} {side} {amount}@{price}): {e}")
            return None

    async def cancel_order(self, order_id: str, symbol: str) -> bool:
        """주문 취소"""
        try:
            await self.exchange.cancel_order(order_id, symbol)
            logger.info(f"주문 취소 성공: {order_id}")
            return True

        except Exception as e:
            logger.error(f"주문 취소 실패 ({order_id}): {e}")
            return False

    async def cancel_all_orders(self, symbol: str = None) -> bool:
        """모든 주문 취소"""
        try:
            if symbol:
                await self.exchange.cancel_all_orders(symbol)
                logger.info(f"모든 주문 취소 성공: {symbol}")
            else:
                # 심볼별로 취소 (OKX는 전체 취소를 지원하지 않을 수 있음)
                open_orders = await self.get_open_orders()
                for order in open_orders:
                    await self.cancel_order(order['id'], order['symbol'])
                logger.info("모든 주문 취소 성공")
            return True

        except Exception as e:
            logger.error(f"모든 주문 취소 실패: {e}")
            return False

    async def get_order_status(self, order_id: str, symbol: str) -> Optional[Dict]:
        """주문 상태 조회"""
        try:
            order = await self.exchange.fetch_order(order_id, symbol)

            return {
                'id': order['id'],
                'symbol': order['symbol'],
                'side': order['side'],
                'amount': float(order['amount']),
                'price': float(order.get('price', 0)) if order.get('price') else None,
                'cost': float(order.get('cost', 0)),
                'filled': float(order.get('filled', 0)),
                'remaining': float(order.get('remaining', 0)),
                'status': order['status'],  # 'open', 'closed', 'canceled'
                'timestamp': order['timestamp'],
                'type': order['type']
            }

        except Exception as e:
            logger.error(f"주문 상태 조회 실패 ({order_id}): {e}")
            return None

    async def get_open_orders(self, symbol: str = None) -> List[Dict]:
        """미체결 주문 조회"""
        try:
            orders = await self.exchange.fetch_open_orders(symbol)

            return [
                {
                    'id': order['id'],
                    'symbol': order['symbol'],
                    'side': order['side'],
                    'amount': float(order['amount']),
                    'price': float(order.get('price', 0)) if order.get('price') else None,
                    'filled': float(order.get('filled', 0)),
                    'remaining': float(order.get('remaining', 0)),
                    'status': order['status'],
                    'timestamp': order['timestamp'],
                    'type': order['type']
                }
                for order in orders
            ]

        except Exception as e:
            logger.error(f"미체결 주문 조회 실패: {e}")
            return []

    async def get_trade_history(self, symbol: str, limit: int = 50) -> List[Dict]:
        """거래 내역 조회"""
        try:
            trades = await self.exchange.fetch_my_trades(symbol, limit=limit)

            return [
                {
                    'id': trade['id'],
                    'order_id': trade['order'],
                    'symbol': trade['symbol'],
                    'side': trade['side'],
                    'amount': float(trade['amount']),
                    'price': float(trade['price']),
                    'cost': float(trade['cost']),
                    'fee': {
                        'currency': trade['fee']['currency'],
                        'cost': float(trade['fee']['cost'])
                    } if trade.get('fee') else None,
                    'timestamp': trade['timestamp']
                }
                for trade in trades
            ]

        except Exception as e:
            logger.error(f"거래 내역 조회 실패 ({symbol}): {e}")
            return []

    # ===== 유틸리티 메서드 =====

    def format_symbol(self, base: str, quote: str) -> str:
        """심볼 포맷팅 (예: BTC, USDT -> BTC/USDT)"""
        return f"{base.upper()}/{quote.upper()}"

    async def get_trading_fee(self, symbol: str) -> Optional[Dict]:
        """거래 수수료 조회"""
        try:
            fees = await self.exchange.fetch_trading_fees()

            if symbol in fees:
                return {
                    'maker': float(fees[symbol]['maker']),
                    'taker': float(fees[symbol]['taker'])
                }
            else:
                # 기본 수수료 (OKX 기본값)
                return {
                    'maker': 0.0008,  # 0.08%
                    'taker': 0.001    # 0.1%
                }

        except Exception as e:
            logger.error(f"거래 수수료 조회 실패: {e}")
            return {
                'maker': 0.0008,
                'taker': 0.001
            }

    async def get_min_trade_amount(self, symbol: str) -> float:
        """최소 거래 금액 조회"""
        try:
            markets = await self.exchange.load_markets()

            if symbol in markets:
                market = markets[symbol]
                # 최소 주문 수량
                min_amount = float(
                    market['limits']['amount']['min']) if market['limits']['amount']['min'] else 0.001
                return min_amount
            else:
                return 0.001  # 기본값

        except Exception as e:
            logger.error(f"최소 거래 금액 조회 실패: {e}")
            return 0.001

    def calculate_order_size(self, symbol: str, usdt_amount: float, price: float) -> float:
        """USDT 금액을 기준으로 주문 수량 계산"""
        try:
            # USDT 금액 / 가격 = 코인 수량
            amount = usdt_amount / price

            # 소수점 자리수 조정 (OKX는 보통 소수점 4자리까지)
            amount = round(amount, 4)

            return amount

        except Exception as e:
            logger.error(f"주문 수량 계산 실패: {e}")
            return 0.0

    async def health_check(self) -> Dict:
        """API 연결 상태 확인"""
        try:
            # 서버 시간 조회로 연결 테스트
            server_time = await self.exchange.fetch_time()

            return {
                'status': 'healthy',
                'connected': self.is_connected,
                'server_time': server_time,
                'local_time': int(datetime.now(timezone.utc).timestamp() * 1000),
                'sandbox': self.sandbox
            }

        except Exception as e:
            return {
                'status': 'error',
                'connected': False,
                'error': str(e),
                'sandbox': self.sandbox
            }


# ===== 팩토리 함수 =====

async def create_okx_client(api_key: str, secret_key: str, passphrase: str, sandbox: bool = True) -> OKXClient:
    """OKX 클라이언트 생성 및 초기화"""
    client = OKXClient(api_key, secret_key, passphrase, sandbox)

    success = await client.initialize()
    if not success:
        raise Exception("OKX API 클라이언트 초기화 실패")

    return client


# ===== 테스트 함수 =====

async def test_okx_client():
    """OKX 클라이언트 테스트"""
    # 테스트용 API 키 (실제 사용 시 환경변수에서 로드)
    api_key = "your-api-key"
    secret_key = "your-secret-key"
    passphrase = "your-passphrase"

    try:
        client = await create_okx_client(api_key, secret_key, passphrase, sandbox=True)

        # 기본 정보 조회
        print("=== OKX API 클라이언트 테스트 ===")

        # 잔고 조회
        balance = await client.get_balance()
        print(f"잔고: {balance}")

        # BTC/USDT 티커 조회
        ticker = await client.get_ticker("BTC/USDT")
        print(f"BTC/USDT 티커: {ticker}")

        # 호가창 조회
        orderbook = await client.get_orderbook("BTC/USDT", 5)
        print(f"BTC/USDT 호가창: {orderbook}")

        # 헬스 체크
        health = await client.health_check()
        print(f"헬스 체크: {health}")

        await client.close()

    except Exception as e:
        print(f"테스트 실패: {e}")


if __name__ == "__main__":
    # 직접 실행 시 테스트
    asyncio.run(test_okx_client())
