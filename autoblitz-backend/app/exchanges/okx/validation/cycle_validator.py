"""
OKX Í±∞Îûò ÏÇ¨Ïù¥ÌÅ¥ Í≤ÄÏ¶ùÍ∏∞ (ÏôÑÏ†Ñ Î≤ÑÏ†Ñ - Import Í≤ΩÎ°ú ÏàòÏ†ï)
ÌååÏùºÎ™Ö: app/exchanges/okx/validation/cycle_validator.py

okx_complete_cycle_test.py + okx_multi_coin_test.py Í≤ÄÏ¶ù Î°úÏßÅ ÌÜµÌï©

Í≤ÄÏ¶ùÎêú Í∏∞Îä•:
- 4Íµ¨Í∞Ñ Îã§Ï§ë ÏΩîÏù∏ ÌÖåÏä§Ìä∏ 
- ÏôÑÏ†ÑÌïú Í±∞Îûò ÏÇ¨Ïù¥ÌÅ¥ Í≤ÄÏ¶ù
- ÏÑ±Îä• Î∞è Ï†ïÌôïÏÑ± Î∂ÑÏÑù
"""

import asyncio
import time
from typing import Dict, List, Optional, Any
from datetime import datetime
import statistics

# Import Í≤ΩÎ°ú ÏàòÏ†ï - ÏàúÌôò Ï∞∏Ï°∞ Î∞©ÏßÄ
import sys
import os

# ÌòÑÏû¨ ÌååÏùºÏùò Ï†àÎåÄ Í≤ΩÎ°úÎ•º Í∏∞Ï§ÄÏúºÎ°ú app ÎîîÎ†âÌÜ†Î¶¨ Í≤ΩÎ°ú Í≥ÑÏÇ∞
current_file = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_file))))
sys.path.insert(0, project_root)

# ÏàòÏ†ïÎêú import Í≤ΩÎ°ú
try:
    from app.exchanges.okx.trading.core_trading import OKXTrader
except ImportError:
    # ÏàúÌôò Ï∞∏Ï°∞ Î∞©ÏßÄÎ•º ÏúÑÌïú ÎåÄÏïà
    print("‚ö†Ô∏è OKXTrader import Ïã§Ìå® - ÏàúÌôò Ï∞∏Ï°∞ Î∞©ÏßÄ Î™®ÎìúÎ°ú Ïã§Ìñâ")
    OKXTrader = None

try:
    from app.services.coin import get_coin_service
except ImportError:
    # ÎåÄÏïà import Í≤ΩÎ°ú
    try:
        from app.services.coin.coin_service import CoinService
        def get_coin_service():
            return CoinService()
    except ImportError:
        print("‚ö†Ô∏è CoinService import Ïã§Ìå® - Î™®Ïùò ÏÑúÎπÑÏä§Î°ú Ïã§Ìñâ")
        def get_coin_service():
            return MockCoinService()


class MockCoinService:
    """Î™®Ïùò ÏΩîÏù∏ ÏÑúÎπÑÏä§ (ÌÖåÏä§Ìä∏Ïö©)"""
    
    def find_coins_by_criteria(self, **kwargs):
        """Î™®Ïùò ÏΩîÏù∏ Í≤ÄÏÉâ"""
        tier = kwargs.get('tier', 'HIGH')
        mock_coins = {
            'HIGH': [
                {'symbol': 'BTC-USDT', 'info': {'current_price': 66000.0, 'volume_24h': 1000000}},
                {'symbol': 'ETH-USDT', 'info': {'current_price': 3200.0, 'volume_24h': 800000}}
            ],
            'MEDIUM': [
                {'symbol': 'SOL-USDT', 'info': {'current_price': 180.0, 'volume_24h': 500000}},
                {'symbol': 'ADA-USDT', 'info': {'current_price': 0.45, 'volume_24h': 300000}}
            ],
            'LOW': [
                {'symbol': 'MATIC-USDT', 'info': {'current_price': 0.65, 'volume_24h': 200000}},
                {'symbol': 'DOT-USDT', 'info': {'current_price': 7.2, 'volume_24h': 150000}}
            ],
            'MICRO': [
                {'symbol': 'SHIB-USDT', 'info': {'current_price': 0.000025, 'volume_24h': 100000}},
                {'symbol': 'PEPE-USDT', 'info': {'current_price': 0.00001, 'volume_24h': 80000}}
            ]
        }
        return mock_coins.get(tier, [])


class MockOKXTrader:
    """Î™®Ïùò OKX Í±∞ÎûòÏûê (ÌÖåÏä§Ìä∏Ïö©)"""
    
    def __init__(self, require_auth=True):
        self.require_auth = require_auth
        self.okx_client = type('MockClient', (), {'auth_available': False})()
    
    async def run_multi_coin_test(self, test_coins, usdt_amount):
        """Î™®Ïùò Îã§Ï§ë ÏΩîÏù∏ ÌÖåÏä§Ìä∏"""
        await asyncio.sleep(1)  # Ïã§Ï†ú Ï≤òÎ¶¨ ÏãúÍ∞Ñ ÏãúÎÆ¨Î†àÏù¥ÏÖò
        
        coin_results = []
        for coin in test_coins:
            # Î™®Ïùò Í±∞Îûò Í≤∞Í≥º ÏÉùÏÑ±
            profit_rate = 0.3 + (hash(coin['symbol']) % 100) / 1000  # 0.3~0.4% ÏàòÏùµÎ•†
            execution_time = 30 + (hash(coin['symbol']) % 20)  # 30~50Ï¥à
            
            coin_results.append({
                'symbol': coin['symbol'],
                'success': True,
                'profit_rate': profit_rate,
                'profit': usdt_amount * profit_rate / 100,
                'total_fees': usdt_amount * 0.1 / 100,  # 0.1% ÏàòÏàòÎ£å
                'dust_rate': 0.001 + (hash(coin['symbol']) % 5) / 10000,  # 0.001~0.005%
                'execution_time': execution_time
            })
        
        return {
            'success': True,
            'coin_results': coin_results,
            'total_profit': sum(r['profit'] for r in coin_results),
            'total_fees': sum(r['total_fees'] for r in coin_results)
        }


class OKXCycleValidator:
    """OKX Í±∞Îûò ÏÇ¨Ïù¥ÌÅ¥ Í≤ÄÏ¶ùÍ∏∞
    
    Í∏∞Îä•:
    - Îã§Ï§ë ÏΩîÏù∏ Í±∞Îûò ÏÇ¨Ïù¥ÌÅ¥ Í≤ÄÏ¶ù
    - 4Íµ¨Í∞Ñ Ìã∞Ïñ¥Î≥Ñ ÌÖåÏä§Ìä∏ (HIGH/MEDIUM/LOW/MICRO)
    - ÏÑ±Í≥º Î∂ÑÏÑù Î∞è ÌÜµÍ≥Ñ
    - ÎçîÏä§Ìä∏Ïú® Î∞è Ï†ïÌôïÏÑ± Í≤ÄÏ¶ù
    """
    
    def __init__(self, require_auth: bool = True):
        """Ï¥àÍ∏∞Ìôî
        
        Args:
            require_auth: API Ïù∏Ï¶ù ÌïÑÏöî Ïó¨Î∂Ä
        """
        # OKX Í±∞Îûò ÌÅ¥ÎûòÏä§ (import Ïã§Ìå® Ïãú Î™®Ïùò ÌÅ¥ÎûòÏä§ ÏÇ¨Ïö©)
        if OKXTrader is not None:
            self.trader = OKXTrader(require_auth=require_auth)
        else:
            print("‚ö†Ô∏è OKXTraderÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏñ¥ MockOKXTraderÎ°ú ÎåÄÏ≤¥")
            self.trader = MockOKXTrader(require_auth=require_auth)
        
        # ÏΩîÏù∏ ÏÑúÎπÑÏä§
        self.coin_service = get_coin_service()
        
        # 4Íµ¨Í∞Ñ ÌÖåÏä§Ìä∏ ÏÑ§Ï†ï
        self.tier_test_config = {
            'HIGH': {'count': 2, 'usdt_amount': 15.0},     # BTC, ETH Îì±
            'MEDIUM': {'count': 2, 'usdt_amount': 12.0},   # SOL, ADA Îì±  
            'LOW': {'count': 2, 'usdt_amount': 10.0},      # MATIC, DOT Îì±
            'MICRO': {'count': 2, 'usdt_amount': 8.0}      # SHIB, PEPE Îì±
        }
        
        # Í≤ÄÏ¶ù Í∏∞Ï§Ä
        self.validation_criteria = {
            'max_dust_rate': 0.01,        # ÏµúÎåÄ ÎçîÏä§Ìä∏Ïú® 1%
            'min_success_rate': 90.0,     # ÏµúÏÜå ÏÑ±Í≥µÎ•† 90%
            'max_execution_time': 120.0,  # ÏµúÎåÄ Ïã§Ìñâ ÏãúÍ∞Ñ 2Î∂Ñ
            'max_order_slippage': 0.5      # ÏµúÎåÄ Ï£ºÎ¨∏ Ïä¨Î¶¨ÌîºÏßÄ 0.5%
        }
        
        # Í≤ÄÏ¶ù Í≤∞Í≥º
        self.validation_results = []
    
    def select_test_coins_by_tier(self, tier: str, count: int) -> List[Dict[str, Any]]:
        """Ìã∞Ïñ¥Î≥Ñ ÌÖåÏä§Ìä∏ ÏΩîÏù∏ ÏÑ†ÌÉù
        
        Args:
            tier: Í∞ÄÍ≤© Ìã∞Ïñ¥ (HIGH, MEDIUM, LOW, MICRO)
            count: ÏÑ†ÌÉùÌï† ÏΩîÏù∏ Ïàò
            
        Returns:
            List[Dict[str, Any]]: ÏÑ†ÌÉùÎêú ÏΩîÏù∏ Î™©Î°ù
        """
        # Ìï¥Îãπ Ìã∞Ïñ¥Ïùò ÏΩîÏù∏ Í≤ÄÏÉâ
        tier_coins = self.coin_service.find_coins_by_criteria(
            tier=tier,
            state='live'  # Í±∞Îûò Í∞ÄÎä•Ìïú ÏΩîÏù∏Îßå
        )
        
        if not tier_coins:
            print(f"‚ö†Ô∏è {tier} Ìã∞Ïñ¥ ÏΩîÏù∏ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§")
            return []
        
        # Í±∞ÎûòÎüâ Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨ÌïòÏó¨ ÏÉÅÏúÑ ÏΩîÏù∏ ÏÑ†ÌÉù
        sorted_coins = sorted(
            tier_coins, 
            key=lambda x: x['info'].get('volume_24h', 0), 
            reverse=True
        )
        
        selected = sorted_coins[:count]
        
        print(f"üìã {tier} Ìã∞Ïñ¥ ÏÑ†ÌÉùÎêú ÏΩîÏù∏:")
        for i, coin_data in enumerate(selected, 1):
            symbol = coin_data['symbol']
            price = coin_data['info'].get('current_price', 0)
            volume = coin_data['info'].get('volume_24h', 0)
            print(f"  {i}. {symbol}: ${price:.6f} (24h Í±∞ÎûòÎüâ: {volume:.0f})")
        
        return [{'symbol': coin['symbol'], 'tier': tier, 'info': coin['info']} for coin in selected]
    
    async def run_tier_validation_test(self, tier: str) -> Dict[str, Any]:
        """Ìã∞Ïñ¥Î≥Ñ Í≤ÄÏ¶ù ÌÖåÏä§Ìä∏ Ïã§Ìñâ
        
        Args:
            tier: ÌÖåÏä§Ìä∏Ìï† Ìã∞Ïñ¥
            
        Returns:
            Dict[str, Any]: Ìã∞Ïñ¥Î≥Ñ ÌÖåÏä§Ìä∏ Í≤∞Í≥º
        """
        config = self.tier_test_config.get(tier, {})
        if not config:
            return {
                'tier': tier,
                'success': False,
                'error': f'Ïïå Ïàò ÏóÜÎäî Ìã∞Ïñ¥: {tier}'
            }
        
        count = config['count']
        usdt_amount = config['usdt_amount']
        
        print(f"\nüéØ {tier} Ìã∞Ïñ¥ Í≤ÄÏ¶ù ÌÖåÏä§Ìä∏ ÏãúÏûë")
        print(f"ÏΩîÏù∏ Ïàò: {count}Í∞ú, ÏΩîÏù∏Îãπ Ìà¨ÏûêÍ∏à: ${usdt_amount} USDT")
        print("-" * 60)
        
        # ÌÖåÏä§Ìä∏ ÏΩîÏù∏ ÏÑ†ÌÉù
        test_coins = self.select_test_coins_by_tier(tier, count)
        
        if not test_coins:
            return {
                'tier': tier,
                'success': False,
                'error': 'ÌÖåÏä§Ìä∏Ìï† ÏΩîÏù∏ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§'
            }
        
        # Îã§Ï§ë ÏΩîÏù∏ ÌÖåÏä§Ìä∏ Ïã§Ìñâ
        test_result = await self.trader.run_multi_coin_test(test_coins, usdt_amount)
        
        # Ìã∞Ïñ¥Î≥Ñ Í≤∞Í≥º Î∂ÑÏÑù
        tier_analysis = self._analyze_tier_results(tier, test_result)
        
        return {
            'tier': tier,
            'success': True,
            'test_result': test_result,
            'analysis': tier_analysis,
            'validation_passed': self._validate_tier_results(tier_analysis)
        }
    
    def _analyze_tier_results(self, tier: str, test_result: Dict[str, Any]) -> Dict[str, Any]:
        """Ìã∞Ïñ¥Î≥Ñ Í≤∞Í≥º Î∂ÑÏÑù
        
        Args:
            tier: Ìã∞Ïñ¥Î™Ö
            test_result: ÌÖåÏä§Ìä∏ Í≤∞Í≥º
            
        Returns:
            Dict[str, Any]: Î∂ÑÏÑù Í≤∞Í≥º
        """
        coin_results = test_result.get('coin_results', [])
        successful_results = [r for r in coin_results if r['success']]
        
        if not successful_results:
            return {
                'tier': tier,
                'total_trades': len(coin_results),
                'successful_trades': 0,
                'success_rate': 0.0,
                'avg_profit_rate': 0.0,
                'avg_dust_rate': 0.0,
                'avg_execution_time': 0.0,
                'total_profit': 0.0,
                'total_fees': 0.0
            }
        
        # ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
        profit_rates = [r['profit_rate'] for r in successful_results]
        dust_rates = [r.get('dust_rate', 0) for r in successful_results]
        execution_times = [r['execution_time'] for r in successful_results]
        profits = [r['profit'] for r in successful_results]
        fees = [r['total_fees'] for r in successful_results]
        
        return {
            'tier': tier,
            'total_trades': len(coin_results),
            'successful_trades': len(successful_results),
            'success_rate': len(successful_results) / len(coin_results) * 100,
            'avg_profit_rate': statistics.mean(profit_rates) if profit_rates else 0,
            'std_profit_rate': statistics.stdev(profit_rates) if len(profit_rates) > 1 else 0,
            'avg_dust_rate': statistics.mean(dust_rates) if dust_rates else 0,
            'max_dust_rate': max(dust_rates) if dust_rates else 0,
            'avg_execution_time': statistics.mean(execution_times) if execution_times else 0,
            'max_execution_time': max(execution_times) if execution_times else 0,
            'total_profit': sum(profits),
            'total_fees': sum(fees),
            'profit_rate_range': {
                'min': min(profit_rates) if profit_rates else 0,
                'max': max(profit_rates) if profit_rates else 0
            }
        }
    
    def _validate_tier_results(self, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Ìã∞Ïñ¥Î≥Ñ Í≤∞Í≥º Í≤ÄÏ¶ù
        
        Args:
            analysis: Î∂ÑÏÑù Í≤∞Í≥º
            
        Returns:
            Dict[str, Any]: Í≤ÄÏ¶ù Í≤∞Í≥º
        """
        validation = {
            'passed': True,
            'issues': [],
            'warnings': []
        }
        
        criteria = self.validation_criteria
        
        # ÏÑ±Í≥µÎ•† Í≤ÄÏ¶ù
        if analysis['success_rate'] < criteria['min_success_rate']:
            validation['passed'] = False
            validation['issues'].append(
                f"ÏÑ±Í≥µÎ•† Î∂ÄÏ°±: {analysis['success_rate']:.1f}% < {criteria['min_success_rate']}%"
            )
        
        # ÎçîÏä§Ìä∏Ïú® Í≤ÄÏ¶ù
        if analysis['max_dust_rate'] > criteria['max_dust_rate']:
            validation['passed'] = False
            validation['issues'].append(
                f"ÎçîÏä§Ìä∏Ïú® Ï¥àÍ≥º: {analysis['max_dust_rate']:.4f}% > {criteria['max_dust_rate']}%"
            )
        
        # Ïã§Ìñâ ÏãúÍ∞Ñ Í≤ÄÏ¶ù
        if analysis['max_execution_time'] > criteria['max_execution_time']:
            validation['warnings'].append(
                f"Ïã§Ìñâ ÏãúÍ∞Ñ ÏßÄÏó∞: {analysis['max_execution_time']:.1f}s > {criteria['max_execution_time']}s"
            )
        
        # ÏàòÏùµÎ•† Í≤ÄÏ¶ù (Í≤ΩÍ≥† ÏàòÏ§Ä)
        if analysis['avg_profit_rate'] < -1.0:  # -1% ÎØ∏Îßå Ïãú Í≤ΩÍ≥†
            validation['warnings'].append(
                f"ÌèâÍ∑† ÏàòÏùµÎ•† ÎÇÆÏùå: {analysis['avg_profit_rate']:.4f}%"
            )
        
        return validation
    
    async def run_complete_4tier_validation(self) -> Dict[str, Any]:
        """4Íµ¨Í∞Ñ ÏôÑÏ†Ñ Í≤ÄÏ¶ù ÌÖåÏä§Ìä∏ Ïã§Ìñâ
        
        Returns:
            Dict[str, Any]: Ï†ÑÏ≤¥ Í≤ÄÏ¶ù Í≤∞Í≥º
        """
        validation_start_time = time.time()
        
        print("üöÄ OKX 4Íµ¨Í∞Ñ ÏôÑÏ†Ñ Í≤ÄÏ¶ù ÌÖåÏä§Ìä∏ ÏãúÏûë")
        print("=" * 70)
        print("Í≤ÄÏ¶ù Íµ¨Í∞Ñ: HIGH ‚Üí MEDIUM ‚Üí LOW ‚Üí MICRO")
        print(f"Í≤ÄÏ¶ù Í∏∞Ï§Ä:")
        print(f"  - ÏµúÎåÄ ÎçîÏä§Ìä∏Ïú®: {self.validation_criteria['max_dust_rate']}%")
        print(f"  - ÏµúÏÜå ÏÑ±Í≥µÎ•†: {self.validation_criteria['min_success_rate']}%")
        print(f"  - ÏµúÎåÄ Ïã§ÌñâÏãúÍ∞Ñ: {self.validation_criteria['max_execution_time']}Ï¥à")
        
        overall_result = {
            'start_time': validation_start_time,
            'tier_results': {},
            'overall_stats': {},
            'validation_summary': {},
            'recommendation': ''
        }
        
        # Í∞Å Ìã∞Ïñ¥Î≥Ñ Í≤ÄÏ¶ù Ïã§Ìñâ
        for tier in ['HIGH', 'MEDIUM', 'LOW', 'MICRO']:
            try:
                tier_result = await self.run_tier_validation_test(tier)
                overall_result['tier_results'][tier] = tier_result
                
                if tier_result['success']:
                    print(f"\n‚úÖ {tier} Ìã∞Ïñ¥ Í≤ÄÏ¶ù ÏôÑÎ£å")
                    analysis = tier_result['analysis']
                    validation = tier_result['validation_passed']
                    
                    print(f"   ÏÑ±Í≥µÎ•†: {analysis['success_rate']:.1f}%")
                    print(f"   ÌèâÍ∑† ÎçîÏä§Ìä∏Ïú®: {analysis['avg_dust_rate']:.6f}%")
                    print(f"   ÌèâÍ∑† ÏàòÏùµÎ•†: {analysis['avg_profit_rate']:+.4f}%")
                    print(f"   Í≤ÄÏ¶ù ÌÜµÍ≥º: {'‚úÖ' if validation['passed'] else '‚ùå'}")
                    
                    if validation['issues']:
                        for issue in validation['issues']:
                            print(f"   ‚ùå {issue}")
                    
                    if validation['warnings']:
                        for warning in validation['warnings']:
                            print(f"   ‚ö†Ô∏è {warning}")
                else:
                    print(f"\n‚ùå {tier} Ìã∞Ïñ¥ Í≤ÄÏ¶ù Ïã§Ìå®: {tier_result.get('error', 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò')}")
                
                # Ìã∞Ïñ¥ Í∞Ñ Í∞ÑÍ≤©
                await asyncio.sleep(3)
                
            except Exception as e:
                print(f"‚ùå {tier} Ìã∞Ïñ¥ Í≤ÄÏ¶ù Ï§ë Ïò§Î•ò: {str(e)}")
                overall_result['tier_results'][tier] = {
                    'tier': tier,
                    'success': False,
                    'error': str(e)
                }
        
        # Ï†ÑÏ≤¥ Í≤∞Í≥º Î∂ÑÏÑù
        overall_result['overall_stats'] = self._calculate_overall_stats(overall_result['tier_results'])
        overall_result['validation_summary'] = self._generate_validation_summary(overall_result)
        overall_result['recommendation'] = self._generate_recommendation(overall_result)
        overall_result['execution_time'] = time.time() - validation_start_time
        
        # ÏµúÏ¢Ö Î≥¥Í≥†ÏÑú Ï∂úÎ†•
        self._print_final_report(overall_result)
        
        return overall_result
    
    def _calculate_overall_stats(self, tier_results: Dict[str, Any]) -> Dict[str, Any]:
        """Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
        
        Args:
            tier_results: Ìã∞Ïñ¥Î≥Ñ Í≤∞Í≥º
            
        Returns:
            Dict[str, Any]: Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ
        """
        successful_tiers = [
            result for result in tier_results.values() 
            if result['success'] and 'analysis' in result
        ]
        
        if not successful_tiers:
            return {
                'total_tiers_tested': len(tier_results),
                'successful_tiers': 0,
                'tier_success_rate': 0.0,
                'total_trades': 0,
                'overall_trade_success_rate': 0.0,
                'total_profit': 0.0,
                'total_fees': 0.0,
                'avg_dust_rate': 0.0,
                'avg_execution_time': 0.0
            }
        
        # Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ ÏßëÍ≥Ñ
        total_trades = sum(r['analysis']['total_trades'] for r in successful_tiers)
        successful_trades = sum(r['analysis']['successful_trades'] for r in successful_tiers)
        total_profit = sum(r['analysis']['total_profit'] for r in successful_tiers)
        total_fees = sum(r['analysis']['total_fees'] for r in successful_tiers)
        
        # Í∞ÄÏ§ë ÌèâÍ∑† Í≥ÑÏÇ∞
        dust_rates = []
        execution_times = []
        
        for tier_result in successful_tiers:
            analysis = tier_result['analysis']
            if analysis['successful_trades'] > 0:
                dust_rates.extend([analysis['avg_dust_rate']] * analysis['successful_trades'])
                execution_times.extend([analysis['avg_execution_time']] * analysis['successful_trades'])
        
        return {
            'total_tiers_tested': len(tier_results),
            'successful_tiers': len(successful_tiers),
            'tier_success_rate': len(successful_tiers) / len(tier_results) * 100,
            'total_trades': total_trades,
            'successful_trades': successful_trades,
            'overall_trade_success_rate': (successful_trades / total_trades * 100) if total_trades > 0 else 0,
            'total_profit': total_profit,
            'total_fees': total_fees,
            'net_profit': total_profit - total_fees,
            'avg_dust_rate': statistics.mean(dust_rates) if dust_rates else 0,
            'max_dust_rate': max(dust_rates) if dust_rates else 0,
            'avg_execution_time': statistics.mean(execution_times) if execution_times else 0
        }
    
    def _generate_validation_summary(self, overall_result: Dict[str, Any]) -> Dict[str, Any]:
        """Í≤ÄÏ¶ù ÏöîÏïΩ ÏÉùÏÑ±
        
        Args:
            overall_result: Ï†ÑÏ≤¥ Í≤∞Í≥º
            
        Returns:
            Dict[str, Any]: Í≤ÄÏ¶ù ÏöîÏïΩ
        """
        tier_results = overall_result['tier_results']
        overall_stats = overall_result['overall_stats']
        criteria = self.validation_criteria
        
        # Ìã∞Ïñ¥Î≥Ñ Í≤ÄÏ¶ù ÌÜµÍ≥º ÌòÑÌô©
        tier_validations = {}
        all_tiers_passed = True
        
        for tier, result in tier_results.items():
            if result['success'] and 'validation_passed' in result:
                tier_validations[tier] = result['validation_passed']['passed']
                if not result['validation_passed']['passed']:
                    all_tiers_passed = False
            else:
                tier_validations[tier] = False
                all_tiers_passed = False
        
        # Ï†ÑÏ≤¥ Í≤ÄÏ¶ù ÌÜµÍ≥º Ïó¨Î∂Ä
        overall_passed = (
            all_tiers_passed and
            overall_stats['overall_trade_success_rate'] >= criteria['min_success_rate'] and
            overall_stats['max_dust_rate'] <= criteria['max_dust_rate']
        )
        
        return {
            'overall_validation_passed': overall_passed,
            'tier_validations': tier_validations,
            'passed_tiers': sum(tier_validations.values()),
            'failed_tiers': len(tier_validations) - sum(tier_validations.values()),
            'key_metrics': {
                'success_rate_check': overall_stats['overall_trade_success_rate'] >= criteria['min_success_rate'],
                'dust_rate_check': overall_stats['max_dust_rate'] <= criteria['max_dust_rate'],
                'execution_time_check': overall_stats['avg_execution_time'] <= criteria['max_execution_time']
            }
        }
    
    def _generate_recommendation(self, overall_result: Dict[str, Any]) -> str:
        """Í∂åÍ≥†ÏÇ¨Ìï≠ ÏÉùÏÑ±
        
        Args:
            overall_result: Ï†ÑÏ≤¥ Í≤∞Í≥º
            
        Returns:
            str: Í∂åÍ≥†ÏÇ¨Ìï≠
        """
        validation_summary = overall_result['validation_summary']
        overall_stats = overall_result['overall_stats']
        
        if validation_summary['overall_validation_passed']:
            return (
                "üéâ Î™®Îì† Í≤ÄÏ¶ùÏùÑ ÌÜµÍ≥ºÌñàÏäµÎãàÎã§! "
                f"ÏÑ±Í≥µÎ•† {overall_stats['overall_trade_success_rate']:.1f}%, "
                f"ÎçîÏä§Ìä∏Ïú® {overall_stats['avg_dust_rate']:.4f}%Î°ú "
                "ÌîÑÎ°úÎçïÏÖò ÌôòÍ≤ΩÏóêÏÑú ÏïàÏ†ÑÌïòÍ≤å ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§."
            )
        
        issues = []
        
        if not validation_summary['key_metrics']['success_rate_check']:
            issues.append(f"ÏÑ±Í≥µÎ•† Í∞úÏÑ† ÌïÑÏöî ({overall_stats['overall_trade_success_rate']:.1f}%)")
        
        if not validation_summary['key_metrics']['dust_rate_check']:
            issues.append(f"ÎçîÏä§Ìä∏Ïú® ÏµúÏ†ÅÌôî ÌïÑÏöî ({overall_stats['max_dust_rate']:.4f}%)")
        
        if validation_summary['failed_tiers'] > 0:
            issues.append(f"{validation_summary['failed_tiers']}Í∞ú Ìã∞Ïñ¥ Í≤ÄÏ¶ù Ïã§Ìå®")
        
        return f"‚ö†Ô∏è Í∞úÏÑ† ÌïÑÏöî: {', '.join(issues)}. Ìï¥Îãπ Ïù¥Ïäà Ìï¥Í≤∞ ÌõÑ Ïû¨Í≤ÄÏ¶ùÏùÑ Í∂åÏû•Ìï©ÎãàÎã§."
    
    def _print_final_report(self, overall_result: Dict[str, Any]):
        """ÏµúÏ¢Ö Î≥¥Í≥†ÏÑú Ï∂úÎ†•
        
        Args:
            overall_result: Ï†ÑÏ≤¥ Í≤∞Í≥º
        """
        print(f"\n{'='*70}")
        print("üèÅ OKX 4Íµ¨Í∞Ñ Í≤ÄÏ¶ù ÌÖåÏä§Ìä∏ ÏµúÏ¢Ö Î≥¥Í≥†ÏÑú")
        print("="*70)
        
        overall_stats = overall_result['overall_stats']
        validation_summary = overall_result['validation_summary']
        
        print(f"üìä Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ:")
        print(f"   ÌÖåÏä§Ìä∏ Ìã∞Ïñ¥: {overall_stats['successful_tiers']}/{overall_stats['total_tiers_tested']}Í∞ú")
        print(f"   Ï¥ù Í±∞Îûò Ïàò: {overall_stats['total_trades']}Ìöå")
        print(f"   Ï†ÑÏ≤¥ ÏÑ±Í≥µÎ•†: {overall_stats['overall_trade_success_rate']:.1f}%")
        print(f"   ÌèâÍ∑† ÎçîÏä§Ìä∏Ïú®: {overall_stats['avg_dust_rate']:.6f}%")
        print(f"   ÏµúÎåÄ ÎçîÏä§Ìä∏Ïú®: {overall_stats['max_dust_rate']:.6f}%")
        print(f"   Ï¥ù ÏàòÏùµ: ${overall_stats['total_profit']:+.6f}")
        print(f"   Ï¥ù ÏàòÏàòÎ£å: ${overall_stats['total_fees']:.6f}")
        print(f"   Ïàú ÏàòÏùµ: ${overall_stats['net_profit']:+.6f}")
        print(f"   ÌèâÍ∑† Ïã§ÌñâÏãúÍ∞Ñ: {overall_stats['avg_execution_time']:.1f}Ï¥à")
        
        print(f"\n‚úÖ Í≤ÄÏ¶ù Í≤∞Í≥º:")
        for tier, passed in validation_summary['tier_validations'].items():
            status = "‚úÖ ÌÜµÍ≥º" if passed else "‚ùå Ïã§Ìå®"
            print(f"   {tier} Ìã∞Ïñ¥: {status}")
        
        print(f"\nüéØ ÏµúÏ¢Ö ÌåêÏ†ï: {'‚úÖ Í≤ÄÏ¶ù ÌÜµÍ≥º' if validation_summary['overall_validation_passed'] else '‚ùå Í≤ÄÏ¶ù Ïã§Ìå®'}")
        print(f"üí° Í∂åÍ≥†ÏÇ¨Ìï≠: {overall_result['recommendation']}")
        print(f"‚è±Ô∏è  Ï¥ù Ïã§ÌñâÏãúÍ∞Ñ: {overall_result['execution_time']:.1f}Ï¥à")


if __name__ == "__main__":
    """ÌÖåÏä§Ìä∏ ÏΩîÎìú"""
    async def test_cycle_validator():
        """ÏÇ¨Ïù¥ÌÅ¥ Í≤ÄÏ¶ùÍ∏∞ ÌÖåÏä§Ìä∏"""
        try:
            print("üîç OKX ÏÇ¨Ïù¥ÌÅ¥ Í≤ÄÏ¶ùÍ∏∞ ÌÖåÏä§Ìä∏")
            print("=" * 50)
            
            # 1. Í≤ÄÏ¶ùÍ∏∞ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± (Ïù∏Ï¶ù ÏóÜÏù¥ ÌÖåÏä§Ìä∏)
            validator = OKXCycleValidator(require_auth=False)
            
            print(f"üîë API Ïù∏Ï¶ù ÏÉÅÌÉú: {'Ïù∏Ï¶ùÎê®' if hasattr(validator.trader, 'okx_client') and getattr(validator.trader.okx_client, 'auth_available', False) else 'Í≥µÍ∞ú APIÎßå ÏÇ¨Ïö©'}")
            
            # 2. Ìã∞Ïñ¥Î≥Ñ ÏΩîÏù∏ ÏÑ†ÌÉù ÌÖåÏä§Ìä∏
            print("\nüìã Ìã∞Ïñ¥Î≥Ñ ÏΩîÏù∏ ÏÑ†ÌÉù ÌÖåÏä§Ìä∏:")
            for tier in ['HIGH', 'MEDIUM', 'LOW', 'MICRO']:
                test_coins = validator.select_test_coins_by_tier(tier, 2)
                print(f"   {tier}: {len(test_coins)}Í∞ú ÏΩîÏù∏ ÏÑ†ÌÉùÎê®")
            
            # 3. Í≤ÄÏ¶ù Í∏∞Ï§Ä Ï∂úÎ†•
            print(f"\nüìè Í≤ÄÏ¶ù Í∏∞Ï§Ä:")
            criteria = validator.validation_criteria
            for key, value in criteria.items():
                print(f"   {key}: {value}")
            
            # 4. Î™®Ïùò 4Íµ¨Í∞Ñ Í≤ÄÏ¶ù Ïã§Ìñâ
            print("\nüß™ Î™®Ïùò 4Íµ¨Í∞Ñ Í≤ÄÏ¶ù ÌÖåÏä§Ìä∏ Ïã§Ìñâ:")
            validation_result = await validator.run_complete_4tier_validation()
            
            print(f"\n‚úÖ ÏÇ¨Ïù¥ÌÅ¥ Í≤ÄÏ¶ùÍ∏∞ ÌÖåÏä§Ìä∏ ÏôÑÎ£å")
            print(f"üìä ÏµúÏ¢Ö Í≤ÄÏ¶ù Í≤∞Í≥º: {'ÌÜµÍ≥º' if validation_result['validation_summary']['overall_validation_passed'] else 'Ïã§Ìå®'}")
            
        except Exception as e:
            print(f"‚ùå ÌÖåÏä§Ìä∏ Ïã§Ìå®: {str(e)}")
            import traceback
            traceback.print_exc()
    
    # ÌÖåÏä§Ìä∏ Ïã§Ìñâ
    asyncio.run(test_cycle_validator())